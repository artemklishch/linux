1. имя файла мот содержать до 255 символов
2. имя файла не должно содержать символ "/"
3. имя файла реггистрозависимое
4. лучше не исползьовать пробелы
5. скрытым файлом в Linux считается файл, имя которого начинается с точки, "."
6. если мы удаляем что-то с помощью комманды "rm" - данные на диске остаются, но ъх почти невозможно найти, т.к. неизвестно где он.
7. если мы получаем результат определенной команды - это значит, что этот результат выводится на стандартный поток вывода (STDOUT), а если получаем ошибку - на поток ошибок (STDERR); 
8. в терминал мы получаем результат команды или сообщение об ошбике, потому что по умолчанию вывод STDOUT/STDERR направлен на терминал, но мы можем перенаправлять это
9. STDOUT имеет номер 1, STDERR имеет номер 2
10. есть также поток ввода (STDIN), не все команды работаю с потоком ввода
11. пример потока ввода: mysql -h server.local -uroot -p < file.sql - таким образом можно перенаправлять информацию из файла в какую-то программу, 
если программа работает со стандартным потоком ввода
12. можно перенаправлять данные из одной команды в поток ввода другой команды; 
например: ls -l /etc/ | less - тут информация в результате команды "ls -l /etc" перенаправляется в команду "less"
13. | - оператор для перенаправления данных из одной команды в другую, работает только со стандартным потоко вывода
14. 


Keyboard/commands:
1. Shift + PageUp/PageDown - листаем экран в терминале, как скроллинг
2. Ctrl + L, clear - очистка места в терминале
3. > - команда для перенаправления вывода результата команды в потоках STDOUT/STDERR, по умолчанию команда > имеет номер 1 (для STDOUT), можно писать команду - 1>
4. > - всегда перезаписывает содерживоме вывода
5. >> - команда которая в потоке дописывает до существующего контента результат вывода с потока
6. rm S* - означает, что будут удалены все файлы, чье имя начинается на букву S; символ * означает любое количество любых символов
7. ? - этот символ означает один любой символ
8. ls -l > stdout - эта последовательность выполняется справа на лево
9. > - при этой команде файл сперва обнуляется, а потом туда записывается новая информация
10. cat - для считывания содержания файла, но также можно объединять содержание нескольких файлов и переность в один общий файл с помощью оператора потока ввода-вывода, 
например: cat test1.txt test2.txt > test3.txt
11. head - выводит первые 10 строк файла, head -1 test3.txt - выводит одну первую строку, 
head -n 1 test3.txt - выводит одну первую строку, но также позовляет использовать допольнительные ключи к команде
12. tail - выводит послежние 10 строк файла, работает как head, но также содержит ключ -f , который оставляет файл открытым в терминале после выполнения команды
13. wc - подсчитывает количество строк/слов/символов, например: wc -l test3.txt - считает строки, wc -w test3.txt - считает количество слов, wc -c test4.txt - символы
14. grep - позволяет искать строки в файлах, отвечающие шаблону поиска, 
например: grep 1 test3.txt - ищет в файле test3.txt строки, содержащие символ "1"; grep -v 1 test3.tx - с ключем -v ищет строки, к-е не содержат символ "1"
15. / - корневой каталог, выше этого каталога каталогов нет
16. cat > test - создает файл з именем test и оставляет открытым терминал для набора текста, который будет сохранен после ввода и выхода из терминала
17. ls -la - показывает в том числе скрытые файлы и папки
18. ls -lA - показывает в том числе скрытые файлы и папки кроме текущей и родительской директории (".", "..")
19. ls -la | grep -v total - получаем все, кроме ".", "..", фильтруем, чтоб убрать значение total и получаем все оставшееся
20. ls -lad ./.* | grep -v total | grep -v "\.$" - получаем все файлы(и файлы и директории), включая скрытые, убираем total, убираем ".", "..", 
выводим файлы и директории, начинающиеся с символа ".". Без ключа d будете выводится только директории
21. "\.$" - означает точка в конце строки
22. grep -v total - если переделать в grep -v ^total - означает, что все кроме строк, к-е начинаются со слова total...
23. ls -lad ./.* | grep -v total | grep -v ^d - выводит только файлы, начинающиеся на символ "."
24. 

Права на файлы и директории:
1. Есть 3 вида ОС: однопользовательские однозадачные (MSDOS); однопользовательские многозадачные (Windows 95); многопользовательские многозадачные (WindowsNT, Unix/Linux)
2. id root - информация о корневом пользователе root
3. Есть 2 вида пользователей: root; все остальные
4. root пользователь не имеет никаких ограничений; 
на остальных пользователей можно наложить ограничения; 
по общему правилу необходимо работать не от имени root, а от имени обычного пользователя (от категории "остальных пользователей"); 
root можно использовать только в случаях, когда обычный пользователь не имеет доступа, например: 
- внести изменения в ОС, 
- добавить новые системные файлы, 
- установить програмное обеспечение, 
- изменить конфигурационные файлы, 
- изменить ядро, изменить способ загрузки 
- и тп
root пользователь всегда! имеет uid равный 0, независимо как мы его переименуем (что не рекомендуется)
5. Обычные пользователи могут быть разделены:
- те, от имени к-х запускаются программы
- те, что пользуются программами
6. Пользователи, чьи uid значения выше 0 и до 1000 (не включая) - это пользователи-демоны, служебные пользователи, 
от имени к-х запускаются службы (иеь-сервер, ftp сервер, автомонтирование и тп)
7. uid процесса равен uid пользователя (?????)
8. есть 3 группы прав: права владельца файла (как правило это тот, кто создал файл), права участника группы владельца файла, все остальные
9. rwx - r - читать, w - записать, x - исполнить; x для каталога означает возможность зайти в каталог через комманду cd
10. Файлы, в к-х содержиится информация о пользователях:
- /etc/passwd - о пользователях
- /etc/group - о группах пользователей
- /etc/shadow - о паролях пользователей
11. less /etc/passwd - root:x:0:0:root:/root:/bin/bash - тут следующие данные: root - имя пользователя; x - раньше тут хранился пароль; 0 - uid пользователя; 
0 - идентификатор группы; root - коментарий, тут может быть любой коментарий для нас; /root - информация о домашнем каталоге (можно изменить); 
/bin/bash - командная оболочка по умолчанию, то, что будет запущено, когда мы зайдем на сервер (можно изменить)
12. cat /etc/group - docker:x:984:artem - docker - группа; x - вместо пароля; 984 - идентификатор группы; artem - те, кто присутствует в группе
13. cat /etc/shadow - 
14. хеш функция трансформирует пароль в строку с набором символов и при аутентификации программа каждый раз трансформирует введенный пароль в хеш и потом сравнивает хеши
15. chmod - команда для настройки прав доступа, например: chmod o-r err - означает: o - others, прочие пользователи; -r - убрать право на чтение (read); err - имя файла.
chmod u-w err - убираем право пользователя-владельца на запись; chmod u+w err - добавляем пользователю-владельцу право на запись; 
chmod g-w err - удаляем у пользователя группы право на запись; chmod -w err - такой вариант будет убирать право записи для пользователя-владельца
и для пользователя группы (когда не уточняем u/g/o); chmod u+rwx,g+rw,o-rwx err - пользователю владельцу добавляем все права, пользователю группы добавляем права на чтение и запись,
у остальных пользователей убираем все права
16. rwxrwxr-x - это выражение прав на файл также представляется как 9 бит; расшифровка "rwx" в восьмеричной системе: r = 4, w = 2, x = 1
17. chmod 760 err === chmod u+rwx,g+rw,o-rwx err
18. Есть три места для хранения информации о файле: 
- место на диске, где сохраняется сама информация; 
- место с мета информацией (кому файл принадлежит, когда создан, права доступа и тп, например Inode), 
например в этом месте хранится такая информация: -rw-r--r-- 1 artem artem   5290 Jan 23 17:19 err; 
комманда ls -li выводит примерно такую информацию: 13668643 -rw-r--r-- 1 artem artem   5290 Jan 23 17:19 err - и тут 13668643 - это номер INode
- название файла или каталога хранится в каталоге; каталог это специальный файл, к-й хранит в себе имена других файлов или каталогов
19. Имя файла - это так называемый hardlink - жесткая ссылка; файл существует, пока существует жесткая ссылка
20. Может быть несколько имен одного файла; в примере 13668643 -rw-r--r-- 1 artem artem   5290 Jan 23 17:19 err - значение, цифра "1" после блока с правами - это число имен файла
21. ln err err_hl - создаем дополнительну жесткую ссылку на файл err и называем новую ссылку err_hl
22. ls -lid - получаем информацию о текущем каталоге
23. удаление жесткой ссылки удалит файл только если это будет посленяя ссылка на файл, если есть несколько жестких ссылок (несколько имен), то это не удалит файл
24. stat err - выводит данные про файл err, подробную информацию про файл из INode 
25. lrwxrwxrwx 1 root root 32 Oct  6 19:20 /etc/localtime -> /usr/share/zoneinfo/Europe/Sofia - в этом примере первая буква l означает мягкую ссылку, 
"/etc/localtime" - мягкая ссылка, к-я указывает на файл "/usr/share/zoneinfo/Europe/Sofia"
26. Мягкие ссылки для того, чтоб взаимодействоать между разными компъютерами; жесткие ссылки могут делать в рамках одного диска, они не могут делать между двумя дисками,
номера iNode уникальны в рамках одного диска; в рамках двух дисков номера INode могут пересекаться, поэтому мы используем мягкие ссылки; также невозможно создать
жесткую ссылку на каталоге; мягкие ссылки могут указывать на файлы на другом диске и могут создаватья для каталога
27. ln -s err err_sl - создаем мягкую ссылку для файла err и называем ее err_sl; мфгкая ссылка получает свой номер INode; всегда имеет права 777
28. ls -l /usr/bin/passwd - выводит -rwsr-xr-x 1 root root 64152 May 30  2024 /usr/bin/passwd - где буква s вместо x внутри значений с правами означает так называемый suid бит,
в бинарном файле /usr/bin/passwd, это значит, что этот файл запускается от имени пользователя root, но другим пользователем; когда есть символ s в правах,
мы можем запускать файл от имени владельца, а не от того, кто их запускает
29. /usr/bin/passwd -  это файл с программой для изменения пароля пользователя
30. добавлять такой бит, символ s - нужно только тогда, когда мы уверены в том, что делаем - чтоб не создавать риск для безопасности, чтоб посторонние пользователи не имели доступ
31. Бит s можно присвоить любому файлу, за исключением скрипта
32. passwd - командя для изменения пароля пользователя в Ubuntu
33. grep artem /etc/shadow - выводит хешированный пароль пользователя ОС
34. в правах на каталог символ x - позоваоляет переходить в каталог через команду cd, разрешает доступ до данных из INode или не разрешает, если x нет
35. chmod g+s - команда, которая присваивает группе вышеупомянутый suid бит
36.  удаление файла определяется правом на каталог, если есть право на удаление на каталоге, то можно будет удалять файлы в этом каталоге
37. перезапись файла, добавление какой то информации в файл, обнуление файла - это работа с файлом, а удаление файла - это работа с каталогом
38. . , .. - скрытые файлы в каталоге, и они означаю хардлинки на текущий и вышестоящий каталоги
39. 


Regular expressions
1. ip a - выводит информацию о сетевых итерфейсах
2. mac адреса складається з 6 пар значень, розділених двокрапками - це числовій значення у 16ковій системі числення, максимальне значення - ff
3. ip a | grep -P '[0-9a-f]:' - получаем информацию об активных интерфейсах, передаем эту информацию в команду grep, ключ -P означает, что мы работаем тут с регулярным выражением
4. grep -P '([0-9a-f]{2}:){5}[0-9a-f]{2}' - выводит список vfc адресов с информации из команды ip a
5. echo 192.168.1.1 | grep -P '25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2}' - получаем числа октеты IP адреса (числа от 0 до 255)
6. . - любой символ в регуларном выражении, поэтому, если ищем именно точку, то экранируем - \. - например - ip a | grep -P '(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\.'
7. ip a | grep -P '((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})' - получаем IP адреса (альтернативное выражение
- ip a | grep -P '((25[0-5]|2[0-4][\d]|1[\d]{2}|[\d]{1,2})\.){3}(25[0-5]|2[0-4][\d]|1[\d]{2}|[\d]{1,2})')
8. echo file.com | grep -P '(.*\..{3})(?<!\.(exe|com)$)' - тут делается негативный поиск

Коды, циклы
1. Если программа отработала без ошибок, то ее код возврата равен 0, если с ошибками - не равен 0
2. echo $? - тут хранится код возврата, эта переменная хранит последний код возврата (последней команды)
3. &&, || - логическое И, логическое ИЛИ
4. ls -l dfgdsg; echo Error - символ ";" (точка-запятая) позволяет выполнять команды поочередно
5. for i in {2015..2020}; do echo $i; done - цикл, выводит годы с 2015 по 2020
6. for y in {2015..2020}; do echo $y; for m in {01..12}; do echo $m; done; done - цикл с вложенным циклом
7. echo $(date +%y) - выводит последние две цыфры текущего года, например, "25"
8. echo $(date +%Y) - выводит весь текущий год, например "2025"
9. for year in {2015..2020}; do for m in {01..12}; do mkdir -p ./$year/$m; for n in {1..9}; do echo $n.txt > ./$year/$m/$n.txt; done; done; done - тут мы перебираем годы, на каждой
итерации мы создае внутренний цикл с перебором числовых значений месяцев; во внутреннем цикле для месяцев мы создаем папки с годами и месяцами; внутри каждой итерации по перебору
месяцев мы создаем внутренний цикл, на каждой итерации которого мы создаем файл и записываем туда текст с названием этого же файла
10. 


Скрипты
1. Если мы создаем файл с расширением .sh и в первой строчке пишем #!/bin/bash - это значит, что програма будет передавать в этот командный интерпретатор
2. #! - эти два символа ставятся в первой строчке и обозначают то, с чем системе работать, и нужно указывать абсолютный путь
3. type bash, whereis ls - комманды, к-е показывают абсолютный путь к указанной программе
4. env - команда, к-я выводит переменные системы
5. /etc/profile - если что-то изменяем в этом файле, то это применяется для всех пользователей
6. когда мы вводим команду, первое, что интерпретатор делает - проверяет, является ли команда встроенной в оболочку, например: type cd - cd is a shell builtin,
type ls - ls is aliased to `ls --color=auto', потом ищет в переменных окружения (к-е можно посмотреть с помощью echo $PATH), например, команда mkdir находится в переменной
окружения /bin,type mkdir - mkdir is /usr/bin/mkdir
7. echo $PATH - сперва bash проверяет, является ли команда встроенной, потом является ли команда псевдонимом, и потом в переменной $PATH
8. hash - команда для работы с кешем, можно смотреть, что запамятовано, можно удалять кеш, сперва программа ищет нужную команду и кеширует ее тут, а потом при такой же команде
достает ее из кеша
9. /bin/sh ~/development/studing/linux/test.sh - /bin/sh - это директива для системы, а не для оболочки
10. большинство команд, к-е мы вводим в терминале - єто внешне исполняемые файлы
11. есть 2 типа команд: внутренние команды ы внешние; внутренние команды, это команды, к-е зашиты в сам bash (например, cd, ls); 
внешние команды, к-е являются просто исполняемымы файлами (например, chmod, mkdir)
12. Для того, чтоб понять является команда внутренней или внешней, можно использовать команду type; type cd - cd is a shell builtin, type chmod - chmod is /usr/bin/chmod
13. PATH=$PATH:/var - тут мы добавляем переменную окружения, файл /var в перечень переменных окружения, к-е разедены двоеточием, например: 
- перед добавлением переменной /var:
 /home/artem/.nvm/versions/node/v22.13.1/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin
- после добавления переменной /var:
/home/artem/.nvm/versions/node/v22.13.1/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/var
в конце добавилась переменная-файл /var
14. $PATH - переменная в памяти, это не файл
15. grep -r - ключ -r означает, рукурсивный поиск
16. grep -r "root" /etc 2> /dev/null - 2> означает тут, что мы перенаправляем второй потом, поток ошибок в друго файл
17. grep -r "root:x" /etc 2> /dev/null - x в "root:x" означает некий "атавизм" пароля, 
пароль захешированный и с помощью этого символа через двоеточие мы правильнее достаем информаци; приблизительный ответ такой команды:
/etc/group-:root:x:0:
/etc/passwd:root:x:0:0:root:/root:/bin/bash
/etc/passwd-:root:x:0:0:root:/root:/bin/bash
/etc/group:root:x:0:
18. /dev/null - это файл под давление вывода; если мы что-то хотим подавить, перенаправляем сюда, этакая "черная дыра"
19. ps -efl - команда, к-я выводит процессы
20. Cron - плаинировщик задач, для запуска програм по расписанию; он не может работать чаще, чем 1 раз в минуту; это рабочая программа, к-я постоянно висит в памяти,
к-я активируется, запускается 1 раз в минуту
21. Cron бывает 2 типов: общий на всю систему и для конкретного пользователя.
22. ls -l /etc/crontab - тут находится конфигурационный файл для общего Cron
23. ls -l /var/spool/cron/crontabs/ - тут находится конфигурационный файл для индивидуального пользователя
24. в /etc/crontab файле мф може прописать настройки команды согласно последоательности временных параметров: минута-час-день-месяц-деньнедели-пользователь-команда;
например, */15 * * * * root come_command - означает, что запускаем какую-то команду каждые 15 минут, каждый час, каждый день, в каждом месяце, в любой день недели
от имени пользователя root; символ "/" указывает именно на каждые 15 минут, а не в 15 минут какого-то времени - если хотим казать в 15 минту какого-то час, то символ "/"
не указываем
25. в конфигурационном фале индивидуального планировщика задач полтзователь не указывается
26. * 2 * * * root some_command - каждый день в 2 часа ночи будет запущена эта команда каждую минуту, то есть 60 раз, поэтому всегда нужно уточнять параметры времени
27. 1 2 * * * root some_command (01 02 * * * root some_command) - команда будет запущена 1 раз в 2 часа ночи
28. высокосный год необходимо прописывать отдельно
29. символ * означает любое значение минуты или часа или другого параметра, */2 - означает, что планировщик запускает задачу каждые 2 единицы соответствующего временного параметра
 2 - означает, что планировщик запускает команду в единицу времни равную 2 (стоит помнить, что планировщик автоматически запускается каждую минуту и проверяет, есть ли задачи 
для запуска в текущее время, поэтому, если например, мы укажем время выполнения задачи * 2 * * * , то планировщик буде запускать команду каждую минуту до тех пор, пока время 
в часах будет равно 2 - чтоб этого не было и чтоб команда выполнилась один раз можно указать минуты в 0 - 0 2 * * 8)
30. crontab -e - команда для создания индивиуального конфигурационного файла-планировщика задач
31. при настройках планировщика задча необходимо учитывать время выполнения задачи; например планировщик задач 1 раз в минуту проверяет команды и срабатывает,
если находит совпадение по времени, и если какая-то программа из планировщика была запущена 1 минуту назад и все еще продолжает свое выполнение,
мы должны позаботится о том, чтоб эта команда не была вызвана снова; для этого можно использовать программу flock, нужно запускать проверки на последующие запуски
32. du -sh /home/artem/ - команда выводит информацию о том, сколько дискового пространства занимает пользователь artem
33. /var/spool/cron/crontabs/ - место, где сохраняется индивидуальный планировщик задач, к-й создается с помощью команды crontab -e
34. 

Web-servers
1. За сетевые составные части TCP/IP, слои трансформации информации, отвечает ядро операционной системы 
2. Apahe2, Nginx - веб сервера - програмы, к-е видят клиент и являются посредниками между клиентом и сервером приложения
3. Apache передает на клиент исключительно HTML; этот сервер ждет когда клиент вернет ответ и это может замедлять пропускную способность обмена данными и приводит к блокировке
процессов обмена информации других клиентов; поэтому этот сервер не используют как правило в виде сервера, к-й общается с фронтендом; может работать с модулями;
4. Nginx - сервер, к-й не ждет ответа от клиента и не останавливает свою работу; и периодически проверяет есть ли ответ от клиента; но у него нет модулей; работает не лучше, 
чем Apache с фронтедом с динамическими данными
5. Примерное использование: идет запрос к веб-серверу Nginx, а этотм запрос Nginx передает Apache - это сделано, чтоб не нарушать скорость работы Apache; 
6. В рамках локальноъ сети Apache - хороший сервер
7. .htaccess - файл на сервере Apache, к-й содержит настройки и если в нем есть ошибка, то не будет работать только этот сайт, с самим сервером Apache ничего не случится, 
он продолжит раюотать, а в Nginx это сервис для работы с конкретным сайтом, он не расчитан на виртуальные хостинги, в случае ошибок не будет работать весь Nginx; 
Nginx подходит для хорошей быстрой работы фронтенда, а для бекенда используют Apache; пользователь общается с Nginx, Nginx общается с Apache
8. файл .htaccess находиится в каталоге самого сайта и является конфигурационным файлом того сайта, в каталоге которого он находится; если в нем будет ошибка, он не вызовет 
поломку всего сервера - только поломку самого сайта, в Nginx такого нет; в Nginx имеется один конфигурационный файл, к к-му подключаются другие файлы, к-е становятся частью этого	
файла, и если где то ошибка, то ломается весь сервер; по сути Nginx предназначен для одного сервера
9. в конфигурационном файле пишут, как будет работаь сервер, на каком порту он работает, от какого пользователя, какие каталоги ему доступны, куда передавать динмаческие данные и тд
10.  

Regexp
1. grep -v "^$" test3 - убирает пробельные строки
2. grep -vP "^\s*$" test3 | tr [:lower:] [:upper:] - вторая часть переводит символы нижнего регистра в верхний регистр
3. -vP - -v означет выводить все что не содержит, P это указание на регулярное выражение
4. sed - "strean editor", считывает данные с файла потоком (с потоком символом) и изменяет по заданному шаблону
5. 

Nginx:
1. Прокси - сервер, через к-й идут запросы туда, куда нам нужно и мы знаем куда идет запрос
2. Обратный прокси - если мы не знаем куда идет запрос. например, фронтенд
3. Балансировщик - опрашивает сервера и передает работу тому серверу, к-й менее загружен.
4. Nginx выбирает сервера в случайном порядке, кроме сервера, к-й недоступен, балансировки он сам по себе не далает
5. Для балансировки необходимо, что все серверы имели примерно одинаковые технические характеристики
6. Есть платные модули Nginx , к-е могут делать балансировку
7. Nginx проксирует запросы на один или несколько серверов Apache
8. 

SSL Сертификаты:
1. симметричное шифрование - когда мы одним и тем же ключем зашифровуем и расшифровуем какие то данные
2. ассимметричное шифрование - есть пара ключей, мы зашифровуем одним ключем и расшифровуем другим ключем; 
один ключ - приватный, второй ключ - публичный; публичный ключ формируется из приватного, существенных технических отличий между ними нет; публичный ключ - в открытом доступе;
приватный ключ храним у себя; если я хочу, чтоб была уверенность, что сообщение действительно идет от меня, я шифрую сообщение своим приватным ключем;
расшифровать такое сообщение может только публичный ключ, являющийся парой к приватному ключу; можно почитать книгу "Прикладная криптография" Шнаера;
ключ - это просто файл; если кто-то хочет зашифровать информацию и передать ее мне, он шифрует информацию публичным ключем и выкладывает ее в общий доступ - 
потому что кроме меня никто не сможет расшифровать эту информацию; расшифровка сообщения, зашифрованного пуьличным ключем работает по такому же принципу - 
расшифровать такое сообщение нельзя тем же самым ключем, в данном случае публичным ключем, и оно может быть расшифровано моим приватным ключем.
3. Если мы зашифровали информацию публичным коючем - мы можем расшифровать ее только приватным; если мы зашифровали информацию приватным ключем - расшифровать ее можно только
публичным ключем.
4. Приватный ключ лежит на веб сервере. А публичный ключ мы получаем когда к нему обращаемся. Сертификат - это по сути публичный ключ. Когда мы обращаемся к серверу, 
мы получаем этот публичный ключ и видим информацию. Если бы это был бы другой сервер, то такой публичный ключ не расшифровал бы информацию. Этот процесс
также связан с работой протокола HTTPS - мы расшифровуем данные, приходящие по этому протоколу, с помощьтю публичного ключа (вернее, это происходит автоматически). 
И если мы передаем свой логин-пароль, например, когда авторизуемся на сайте, они шифруются публичным ключем и отправляются в шифрованном виде на сервер.
Расшифровать их может только сервер, кроме сервера эту информацию никто не расшифрует. 
5. Блокчейн - это по сути децентралиованная база данных.
6. Как нам обезопасить свое первое обращение к серверу? Мы должны как-то сертифицировать наш публичный ключ. Мы, как владелец сервера, идем к специальной организации,
которая является удостоверяющим центром. Мы даем этой организации свой публичный ключ, даем документы, пожтверждающие то, что мы - владелец сервера, этот
сайт принадлежит нам. Удостоверяющий центр проверяет наш публичный ключ и подписывает его, добавляет свою небольшую шифрующую часть.
После этого мой сертификат является подписанным(подтвержденным) и тогда этот сертификат означает, что это публичный ключ достоверный.
Кроме того, удостоверяющий центр имеет свой публичный и приватный ключи. Когда удостоверяющий центр проврил, что публичный ключ подтвержден, он свою подпись шифрует своим приватным
ключем и добавляет к публичному ключу того сайту, к-й он подтверждает. Соответственно расшифровать такую информацию можно, когда у нас есть публичный ключ удостоверяющего центра.
То есть у нас еть два публичных ключа: публичный ключ владельца сайта и публичный ключ удостоверяющего центра.
7. Производители браузеров встраивают в браузеры публичные ключи удостоверяющих центров.
8. Когда идет запрос с сайта на сервер: нам приходит информация с публичным ключем сайта; если этот публичный ключ сайта подписан ключем удостоверяющего центра, 
то все хорошо, информация расшифровуется и мы видим расшифрованную информацию, как есть; если публичный ключ владельца сайта не подписан удостоверяющим центром,
мы видим на странице сообщение о том, что сайт не безопасен (или что-то вроде того); а может быть ситуация, когда публичный ключ владельца сайта подписан, но
неизвестно кем.
9. Когда все хорошо - мы видим иконку замка в левом верхнем углу рядом с URL
10. 

Server:
1. Пактетный менеджер - это программа в Linux, к-я работает с програмными пакетами; 
2. Чтоб установить програмное обеспечение в Linux, нужно переписать наш исполняемый файл
3. Пакет - это бинарный исполняемый файл с информацией
4. С пакетами работает команда dpkg
5. Но удобнее рабтать с репозиториями. В этом случае легче устанавливать зависимости.
6. Чтоб искать пакеты в репозитории -  apt-cache search
7. apt-cache search server | grep -i http | grep -i apache - находим пакеты для вебсервера Apache (apache2 - Apache HTTP Server - пакет)
8. apt-cache search - ищет пакет в репозитории по заданному слову
9. Порт - идентификатор приложения, http - 80 порт по умолчанию
10. netstat -tnlp - показывает активные работающие порты
11. Apache и Nginx по умолчанию смотрят на порт 80
12. ps -efl - выводит списк всех работающих процессов на нашем сервер
13. ^$ - регулярное выражение, означающее пустую строку; grep -v ^$ - убирает пустые строки
14. Если мы изменяем кофигурационный файл сервера, нужно сделать релоад или рестарт сервера Apache - иначе изменения не применятся (если рестарт, то сервер будет перезагружатся 
и программа може несколько секунд не работать, поэту обычно делают релоад)
15. Конфигурационные файлы отдельных файлов находятся в каталоге - /etc/apache2/sites-enabled/
16. /etc/apache2/sites-available/ - этот каталог по умолчанию не подгружается в конфигурационный файл /etc/apache2/apache2.conf
17. Если мы хотим добавить конфигурационный фал для отдельного сайта, мы создаем такой конфигурационный файл в каталоге /etc/apache2/sites-available/, 
прописываем в нем все необходимые опции; если мы хотим включить этот сайт, мы вносим изменение в файл /etc/apache2/sites-enabled/, где делаем симлинк (ссылку) на этот
файл в каталоге /etc/apache2/sites-available/
18. вывод данных дефолтного файла - grep -v "#" /etc/apache2/sites-available/000-default.conf :
<VirtualHost *:80>

	ServerAdmin webmaster@localhost
	DocumentRoot /var/www/html


	ErrorLog ${APACHE_LOG_DIR}/error.log
	CustomLog ${APACHE_LOG_DIR}/access.log combined

</VirtualHost>
,- где
ServerAdmin webmaster@localhost - почта системного администратора
DocumentRoot /var/www/html - каталог с сайтом, где хранятся наши документы
19. /var/www - каталог с сайтами
20. a2ensite 8080 - команда создает ссылку конфигурационного файла /etc/apache2/sites-available/8080.conf в каталоге /etc/apache2/sites-enable/ 
(/etc/apache2/sites-enable/8080.conf); это аналог команды ln -s
21. Для бекенда и nginx нужно сделать директиву, к-я будет показывать пул адресов для nginx (называется  upsteam), поток, 
и нужно сделать директиву непосредственно для сайта, к-я на порту 80 и называется proxy_pass (задается дополнительное значение в файле /etc/nginx/sites-enabled/default в блоке 
location - proxy_pass http://apache; - "apache" в этой строке это совпадение с названием, к-е мы задаем в файле настйроки upstream (я в этом примере на момент 
написания тестового файла называл файл /etc/nginx/sites-available/upstream-test - может быть зазвано по другому, но на уровне с файлом default))
22. Пример файла upstream:
upstream apache {
        server 127.0.0.1:8080;
        server 127.0.0.1:8081;
        server 127.0.0.1:8082;
}
- этот пример под тестовые примеры с тремя портами; мы хотим, чтоб nginx перенаправлял запросы в apache сервер, работающий на 3 портах, чтоб была балансировка 
перенаправления запросов
23. Для того, чтоб отключить сайт, но не удалять конфигурационный файл можно удалить ссылку в каталоге /etc/apache2/sites-enabled - НО У МЕНЯ так не работает
отключение сайта с убранным портом; а у меня получается отключить порт, если в директиве:
upstream apache {
        server 127.0.0.1:8080;
        server 127.0.0.1:8081;
        server 127.0.0.1:8082;
}
- закоментировать или убрать соответсвующий порт, например:
upstream apache {
        #server 127.0.0.1:8080;
        server 127.0.0.1:8081;
        server 127.0.0.1:8082;
}
24. При изменениях в конфигурационных файлах nginx или apache нужно перезагружать соответствующий веб-сервер через systemctl reload ...
25. 

DNS:
1. Служба доменных имен
2. 127.0.0.1 это localhost
3. /etc/hosts - содержит соответствия имени и IP адреса
4. host localhost возвращает 127.0.0.1
5. Как правило адрес DNS сервера совпадает с адресом роутера
6. DNS сервер в Linux прописывается в файле cat /etc/resolv.conf, у меня nameserver 127.0.0.53 - адрес роутера
7. Порядок получения IP адреса: сперва программа проверяет файл /etc/hosts, а потом на сервере - поэтому, если мы прпишем какое то жесткое значение в этом файле, то 
дальше программа не будет проверять на сервере - этот порядок установлен по умолчанию
8. Если не работает запрос, это может быть связано с проблемой в DNS, но доступ через IP адрес напрямую, а не через имя хоста может оказаться рабочим
9. IP адрес виртуальной машины отличается от IP адреса хостовой машины
10. хостовая машина - это машина, на к-й работает гиперюзер, виртуал бокс, к-й выделяет ресурсы для определенной другой виртуальной машины, врамках этих
ресурсов у нас работает другая операционная система; то есть у нас как бы есть два компьютера: один реальный, второй - виртуальный, к-й физически работает на реальном.
Эти две машины изолированы друг от друга
11. 



SOA, Docker:
1. виртуализация - объединение группы ресурсов в одну систему и на этой системе работает другая ОС; паравиртуализация - мы должны на нашу гостевую ОС ставить доработанную ОС,
система общается не напрямую с процессором, а через системные вызовы с хостовой ОС
2. SOA - сервисно ориентированная архитектура
3. в современных ОС все программы общаются с ядром (например, с Linux ОС оболочкой), а ядро общается с оборудованием
4. Віртуалізація — це технологія, яка дозволяє на одному фізичному комп'ютері запускати декілька віртуальних машин (VM), кожна з яких поводиться як справжній окремий комп'ютер.
Тобто:
Є один реальний сервер (його часто називають host).
На ньому працює гіпервізор (Hypervisor) — програма, яка створює і керує віртуальними машинами.
Кожна віртуальна машина (VM) має свою операційну систему, свої ресурси (пам'ять, процесор, диск).
Гіпервізор = програма для управління віртуалізацією. Наприклад: VMware ESXi, KVM, Hyper-V.
Типи гіпервізорів:
Тип 1 ("bare-metal") — встановлюється безпосередньо на сервер (напр., VMware ESXi).
Тип 2 — працює поверх операційної системи (напр., VirtualBox, VMware Workstation).
5. Паравіртуалізація (Paravirtualization)
Паравіртуалізація — це варіант віртуалізації, але тут віртуальні машини "знають", що вони працюють у віртуальному середовищі.
Тобто:
Звичайна віртуалізація намагається приховати від віртуальної машини той факт, що вона — "не справжній комп'ютер".
А при паравіртуалізації гостьова ОС адаптується до роботи у віртуальному середовищі:
Спеціально змінюється ядро ОС.
ОС співпрацює з гіпервізором для більш швидкої роботи (менше витрат на емуляцію заліза).
6. 
Ключова різниця:
Віртуалізація							Паравіртуалізація
Гостьова ОС не знає, що вона віртуальна				Гостьова ОС знає про віртуалізацію
Вища прозорість, але може бути більше оверхеду (на емуляцію)	Краща продуктивність, бо немає потреби емуляції деяких речей
Можна запускати "незмінені" ОС (будь-які Windows, Linux)	Потрібна ОС, яка підтримує паравіртуалізацію (змінене ядро)
🔵 Дуже простий приклад:
Віртуалізація:
У тебе на ноутбуці стоїть VirtualBox, і ти запускаєш Windows всередині Linux. Windows взагалі "не підозрює", що вона віртуальна.
Паравіртуалізація:
Ти спеціально модифікуєш Linux так, щоб він знав, що працює у віртуалізованому середовищі, і напряму звертався до гіпервізора для деяких операцій — так виходить швидше і ефективніше.
7. контейнер - это программа с необходимым перечнем ресурсов для ее работы, к-я ограничена наьором ресурсов сервера; то есть она работает в рамках одного каталога 
и мы ее можем ограничить в рамках вычислительных ресурсов; это не виртуальная машина;
8. докер - набор специальных вызовов для работы с контейнером; докер работает с контейнером лучше всего; если что-то случится с контейнером, мы не сможем это починить; 
9. виртуальные машины применются, когда необходимо разделить ресурсы одного сервера на несколько составляющих и каждая составляющая представляет собой 
какой-то сервис; когда у нас есть какая-то программа (к-я может представлять собой сборку других програм), то используем контейнер
10.  в контейнере лучше ничего не изменять и не хранить
11. сам контейнер не представляет ценности - ценность представляет образ
12. Контейнер — це легка, ізольована середа, в якій можна запустити додаток разом із усіма його залежностями (бібліотеками, конфігураціями і т.д.).
При цьому контейнер ділить ядро операційної системи з іншими контейнерами, але працює незалежно, ніби окремий комп'ютер.
🔵 Порівняння: Контейнер vs Віртуальна машина
Віртуальна машина	Контейнер
Потрібна окрема гостьова ОС для кожної машини	Всі контейнери ділять одне ядро ОС
Більш важка і повільна (гігабайти)	Дуже легка і швидка (мегабайти)
Довгий час запуску	Запуск за секунди
Більше споживання ресурсів	Менше споживання ресурсів
🔵 Простий приклад
Ти написав вебдодаток на Java.
Щоб запустити його на іншому сервері, треба:
встановити JDK,
налаштувати системні змінні,
підняти базу даних,
налаштувати мережу.
З контейнером:
Ти все пакуєш у контейнер (наприклад, за допомогою Docker), і на будь-якому сервері, де стоїть Docker, просто запускаєш одну команду:
docker run my-java-app
І все працює, без болі й довгих налаштувань!
13. Коротко: Контейнер — це
✅ Програма + всі залежності
✅ Ізольоване середовище
✅ Дуже швидкий запуск
✅ Легка передача між серверами
✅ Часто використовують у DevOps, Cloud (AWS, Azure, GCP)
14. Есть образ контейнера - файлы, к-е обспечивают работу программы, контейнер - запущенная программа из образа
15. крайне не рекомендуется делать базу данных в контейнере; 
16. docker search nginx - ищет сервиc nginx
17. docker run -d -p 80:80 nginx - запускаем nginx сервис (веб-сервер nginx) в докер контейнере; -d означает запустить в фоновом режием и выйти (deamon), -p означает
настйроку портов контейнера и хостового компьютера - первое значение порта перед двоеточием -порт контейнер. второе значение - порт нашего компьютера;
80:80 озгначает, что 80 порт контейнера связывается с 80 портом нашего компьютера
18. docker exec -ti 56a430ca49e0 bash - означает зайти внутрь работающего контейнера с идентификатором 56a430ca49e0, где также оступны команды докера
19. если нужно изменить контейнер - нужно изменить образ, а потом пересобрать(пересоздать) контейнер
20. docker inspect nginx - выводит Dockerfile сервиса nginx
21. NAT - network address translation, PAT - port address translation
22. iptables-save - це команда, яка зберігає поточні правила фаєрволу (iptables) у текстовому форматі.
Вона просто виводить всі правила (фільтри, NAT, форвардинги тощо), які зараз налаштовані у ядрі Linux.
Docker активно використовує iptables для налаштування мережевих правил:
створює власні ланцюги (DOCKER, DOCKER-ISOLATION),
пробиває порти контейнерів (-p),
налаштовує NAT для виходу контейнерів в інтернет.
Тому іноді, коли ти працюєш з Docker'ом і хочеш подивитися:
як він налаштував правила мережі,
чому не працює порт,
чому контейнер не доступний ззовні.
Навіщо реально використовують iptables-save?
Перевірити поточні налаштування фаєрволу
Зберегти правила у файл для резервного копіювання
Передати правила на інший сервер
Налагоджувати мережеві проблеми (наприклад, якщо контейнер не має доступу в інтернет)
23. докер выставлять наружу во внешний мир нельзя - он не содержит никаких средстав защиты от постороннего вмешательства, если использвать докер не по назначению
24. нельзя делать из докера виртуальную машину
25. 


























