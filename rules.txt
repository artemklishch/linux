1. имя файла мот содержать до 255 символов
2. имя файла не должно содержать символ "/"
3. имя файла реггистрозависимое
4. лучше не исползьовать пробелы
5. скрытым файлом в Linux считается файл, имя которого начинается с точки, "."
6. если мы удаляем что-то с помощью комманды "rm" - данные на диске остаются, но ъх почти невозможно найти, т.к. неизвестно где он.
7. если мы получаем результат определенной команды - это значит, что этот результат выводится на стандартный поток вывода (STDOUT), а если получаем ошибку - на поток ошибок (STDERR); 
8. в терминал мы получаем результат команды или сообщение об ошбике, потому что по умолчанию вывод STDOUT/STDERR направлен на терминал, но мы можем перенаправлять это
9. STDOUT имеет номер 1, STDERR имеет номер 2
10. есть также поток ввода (STDIN), не все команды работаю с потоком ввода
11. пример потока ввода: mysql -h server.local -uroot -p < file.sql - таким образом можно перенаправлять информацию из файла в какую-то программу, 
если программа работает со стандартным потоком ввода
12. можно перенаправлять данные из одной команды в поток ввода другой команды; 
например: ls -l /etc/ | less - тут информация в результате команды "ls -l /etc" перенаправляется в команду "less"
13. | - оператор для перенаправления данных из одной команды в другую, работает только со стандартным потоко вывода
14. 


Keyboard/commands:
1. Shift + PageUp/PageDown - листаем экран в терминале, как скроллинг
2. Ctrl + L, clear - очистка места в терминале
3. > - команда для перенаправления вывода результата команды в потоках STDOUT/STDERR, по умолчанию команда > имеет номер 1 (для STDOUT), можно писать команду - 1>
4. > - всегда перезаписывает содерживоме вывода
5. >> - команда которая в потоке дописывает до существующего контента результат вывода с потока
6. rm S* - означает, что будут удалены все файлы, чье имя начинается на букву S; символ * означает любое количество любых символов
7. ? - этот символ означает один любой символ
8. ls -l > stdout - эта последовательность выполняется справа на лево
9. > - при этой команде файл сперва обнуляется, а потом туда записывается новая информация
10. cat - для считывания содержания файла, но также можно объединять содержание нескольких файлов и переность в один общий файл с помощью оператора потока ввода-вывода, 
например: cat test1.txt test2.txt > test3.txt
11. head - выводит первые 10 строк файла, head -1 test3.txt - выводит одну первую строку, 
head -n 1 test3.txt - выводит одну первую строку, но также позовляет использовать допольнительные ключи к команде
12. tail - выводит послежние 10 строк файла, работает как head, но также содержит ключ -f , который оставляет файл открытым в терминале после выполнения команды
13. wc - подсчитывает количество строк/слов/символов, например: wc -l test3.txt - считает строки, wc -w test3.txt - считает количество слов, wc -c test4.txt - символы
14. grep - позволяет искать строки в файлах, отвечающие шаблону поиска, 
например: grep 1 test3.txt - ищет в файле test3.txt строки, содержащие символ "1"; grep -v 1 test3.tx - с ключем -v ищет строки, к-е не содержат символ "1"
15. / - корневой каталог, выше этого каталога каталогов нет
16. cat > test - создает файл з именем test и оставляет открытым терминал для набора текста, который будет сохранен после ввода и выхода из терминала
17. ls -la - показывает в том числе скрытые файлы и папки
18. ls -lA - показывает в том числе скрытые файлы и папки кроме текущей и родительской директории (".", "..")
19. ls -la | grep -v total - получаем все, кроме ".", "..", фильтруем, чтоб убрать значение total и получаем все оставшееся
20. ls -lad ./.* | grep -v total | grep -v "\.$" - получаем все файлы(и файлы и директории), включая скрытые, убираем total, убираем ".", "..", 
выводим файлы и директории, начинающиеся с символа ".". Без ключа d будете выводится только директории
21. "\.$" - означает точка в конце строки
22. grep -v total - если переделать в grep -v ^total - означает, что все кроме строк, к-е начинаются со слова total...
23. ls -lad ./.* | grep -v total | grep -v ^d - выводит только файлы, начинающиеся на символ "."
24. 

Права на файлы и директории:
1. Есть 3 вида ОС: однопользовательские однозадачные (MSDOS); однопользовательские многозадачные (Windows 95); многопользовательские многозадачные (WindowsNT, Unix/Linux)
2. id root - информация о корневом пользователе root
3. Есть 2 вида пользователей: root; все остальные
4. root пользователь не имеет никаких ограничений; 
на остальных пользователей можно наложить ограничения; 
по общему правилу необходимо работать не от имени root, а от имени обычного пользователя (от категории "остальных пользователей"); 
root можно использовать только в случаях, когда обычный пользователь не имеет доступа, например: 
- внести изменения в ОС, 
- добавить новые системные файлы, 
- установить програмное обеспечение, 
- изменить конфигурационные файлы, 
- изменить ядро, изменить способ загрузки 
- и тп
root пользователь всегда! имеет uid равный 0, независимо как мы его переименуем (что не рекомендуется)
5. Обычные пользователи могут быть разделены:
- те, от имени к-х запускаются программы
- те, что пользуются программами
6. Пользователи, чьи uid значения выше 0 и до 1000 (не включая) - это пользователи-демоны, служебные пользователи, 
от имени к-х запускаются службы (иеь-сервер, ftp сервер, автомонтирование и тп)
7. uid процесса равен uid пользователя (?????)
8. есть 3 группы прав: права владельца файла (как правило это тот, кто создал файл), права участника группы владельца файла, все остальные
9. rwx - r - читать, w - записать, x - исполнить; x для каталога означает возможность зайти в каталог через комманду cd
10. Файлы, в к-х содержиится информация о пользователях:
- /etc/passwd - о пользователях
- /etc/group - о группах пользователей
- /etc/shadow - о паролях пользователей
11. less /etc/passwd - root:x:0:0:root:/root:/bin/bash - тут следующие данные: root - имя пользователя; x - раньше тут хранился пароль; 0 - uid пользователя; 
0 - идентификатор группы; root - коментарий, тут может быть любой коментарий для нас; /root - информация о домашнем каталоге (можно изменить); 
/bin/bash - командная оболочка по умолчанию, то, что будет запущено, когда мы зайдем на сервер (можно изменить)
12. cat /etc/group - docker:x:984:artem - docker - группа; x - вместо пароля; 984 - идентификатор группы; artem - те, кто присутствует в группе
13. cat /etc/shadow - 
14. хеш функция трансформирует пароль в строку с набором символов и при аутентификации программа каждый раз трансформирует введенный пароль в хеш и потом сравнивает хеши
15. chmod - команда для настройки прав доступа, например: chmod o-r err - означает: o - others, прочие пользователи; -r - убрать право на чтение (read); err - имя файла.
chmod u-w err - убираем право пользователя-владельца на запись; chmod u+w err - добавляем пользователю-владельцу право на запись; 
chmod g-w err - удаляем у пользователя группы право на запись; chmod -w err - такой вариант будет убирать право записи для пользователя-владельца
и для пользователя группы (когда не уточняем u/g/o); chmod u+rwx,g+rw,o-rwx err - пользователю владельцу добавляем все права, пользователю группы добавляем права на чтение и запись,
у остальных пользователей убираем все права
16. rwxrwxr-x - это выражение прав на файл также представляется как 9 бит; расшифровка "rwx" в восьмеричной системе: r = 4, w = 2, x = 1
17. chmod 760 err === chmod u+rwx,g+rw,o-rwx err
18. Есть три места для хранения информации о файле: 
- место на диске, где сохраняется сама информация; 
- место с мета информацией (кому файл принадлежит, когда создан, права доступа и тп, например Inode), 
например в этом месте хранится такая информация: -rw-r--r-- 1 artem artem   5290 Jan 23 17:19 err; 
комманда ls -li выводит примерно такую информацию: 13668643 -rw-r--r-- 1 artem artem   5290 Jan 23 17:19 err - и тут 13668643 - это номер INode
- название файла или каталога хранится в каталоге; каталог это специальный файл, к-й хранит в себе имена других файлов или каталогов
19. Имя файла - это так называемый hardlink - жесткая ссылка; файл существует, пока существует жесткая ссылка
20. Может быть несколько имен одного файла; в примере 13668643 -rw-r--r-- 1 artem artem   5290 Jan 23 17:19 err - значение, цифра "1" после блока с правами - это число имен файла
21. ln err err_hl - создаем дополнительну жесткую ссылку на файл err и называем новую ссылку err_hl
22. ls -lid - получаем информацию о текущем каталоге
23. удаление жесткой ссылки удалит файл только если это будет посленяя ссылка на файл, если есть несколько жестких ссылок (несколько имен), то это не удалит файл
24. stat err - выводит данные про файл err, подробную информацию про файл из INode 
25. lrwxrwxrwx 1 root root 32 Oct  6 19:20 /etc/localtime -> /usr/share/zoneinfo/Europe/Sofia - в этом примере первая буква l означает мягкую ссылку, 
"/etc/localtime" - мягкая ссылка, к-я указывает на файл "/usr/share/zoneinfo/Europe/Sofia"
26. Мягкие ссылки для того, чтоб взаимодействоать между разными компъютерами; жесткие ссылки могут делать в рамках одного диска, они не могут делать между двумя дисками,
номера iNode уникальны в рамках одного диска; в рамках двух дисков номера INode могут пересекаться, поэтому мы используем мягкие ссылки; также невозможно создать
жесткую ссылку на каталоге; мягкие ссылки могут указывать на файлы на другом диске и могут создаватья для каталога
27. ln -s err err_sl - создаем мягкую ссылку для файла err и называем ее err_sl; мфгкая ссылка получает свой номер INode; всегда имеет права 777
28. ls -l /usr/bin/passwd - выводит -rwsr-xr-x 1 root root 64152 May 30  2024 /usr/bin/passwd - где буква s вместо x внутри значений с правами означает так называемый suid бит,
в бинарном файле /usr/bin/passwd, это значит, что этот файл запускается от имени пользователя root, но другим пользователем; когда есть символ s в правах,
мы можем запускать файл от имени владельца, а не от того, кто их запускает
29. /usr/bin/passwd -  это файл с программой для изменения пароля пользователя
30. добавлять такой бит, символ s - нужно только тогда, когда мы уверены в том, что делаем - чтоб не создавать риск для безопасности, чтоб посторонние пользователи не имели доступ
31. Бит s можно присвоить любому файлу, за исключением скрипта
32. passwd - командя для изменения пароля пользователя в Ubuntu
33. grep artem /etc/shadow - выводит хешированный пароль пользователя ОС
34. в правах на каталог символ x - позоваоляет переходить в каталог через команду cd, разрешает доступ до данных из INode или не разрешает, если x нет
35. chmod g+s - команда, которая присваивает группе вышеупомянутый suid бит
36.  удаление файла определяется правом на каталог, если есть право на удаление на каталоге, то можно будет удалять файлы в этом каталоге
37. перезапись файла, добавление какой то информации в файл, обнуление файла - это работа с файлом, а удаление файла - это работа с каталогом
38. . , .. - скрытые файлы в каталоге, и они означаю хардлинки на текущий и вышестоящий каталоги
39. 


Regular expressions
1. ip a - выводит информацию о сетевых итерфейсах
2. mac адреса складається з 6 пар значень, розділених двокрапками - це числовій значення у 16ковій системі числення, максимальне значення - ff
3. ip a | grep -P '[0-9a-f]:' - получаем информацию об активных интерфейсах, передаем эту информацию в команду grep, ключ -P означает, что мы работаем тут с регулярным выражением
4. grep -P '([0-9a-f]{2}:){5}[0-9a-f]{2}' - выводит список vfc адресов с информации из команды ip a
5. echo 192.168.1.1 | grep -P '25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2}' - получаем числа октеты IP адреса (числа от 0 до 255)
6. . - любой символ в регуларном выражении, поэтому, если ищем именно точку, то экранируем - \. - например - ip a | grep -P '(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\.'
7. ip a | grep -P '((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})' - получаем IP адреса (альтернативное выражение
- ip a | grep -P '((25[0-5]|2[0-4][\d]|1[\d]{2}|[\d]{1,2})\.){3}(25[0-5]|2[0-4][\d]|1[\d]{2}|[\d]{1,2})')
8. echo file.com | grep -P '(.*\..{3})(?<!\.(exe|com)$)' - тут делается негативный поиск

Коды, циклы
1. Если программа отработала без ошибок, то ее код возврата равен 0, если с ошибками - не равен 0
2. echo $? - тут хранится код возврата, эта переменная хранит последний код возврата (последней команды)
3. &&, || - логическое И, логическое ИЛИ
4. ls -l dfgdsg; echo Error - символ ";" (точка-запятая) позволяет выполнять команды поочередно
5. for i in {2015..2020}; do echo $i; done - цикл, выводит годы с 2015 по 2020
6. for y in {2015..2020}; do echo $y; for m in {01..12}; do echo $m; done; done - цикл с вложенным циклом
7. echo $(date +%y) - выводит последние две цыфры текущего года, например, "25"
8. echo $(date +%Y) - выводит весь текущий год, например "2025"
9. for year in {2015..2020}; do for m in {01..12}; do mkdir -p ./$year/$m; for n in {1..9}; do echo $n.txt > ./$year/$m/$n.txt; done; done; done - тут мы перебираем годы, на каждой
итерации мы создае внутренний цикл с перебором числовых значений месяцев; во внутреннем цикле для месяцев мы создаем папки с годами и месяцами; внутри каждой итерации по перебору
месяцев мы создаем внутренний цикл, на каждой итерации которого мы создаем файл и записываем туда текст с названием этого же файла
10. 


Скрипты
1. Если мы создаем файл с расширением .sh и в первой строчке пишем #!/bin/bash - это значит, что програма будет передавать в этот командный интерпретатор
2. #! - эти два символа ставятся в первой строчке и обозначают то, с чем системе работать, и нужно указывать абсолютный путь
3. type bash, whereis ls - комманды, к-е показывают абсолютный путь к указанной программе
4. env - команда, к-я выводит переменные системы
5. /etc/profile - если что-то изменяем в этом файле, то это применяется для всех пользователей
6. когда мы вводим команду, первое, что интерпретатор делает - проверяет, является ли команда встроенной в оболочку, например: type cd - cd is a shell builtin,
type ls - ls is aliased to `ls --color=auto', потом ищет в переменных окружения (к-е можно посмотреть с помощью echo $PATH), например, команда mkdir находится в переменной
окружения /bin,type mkdir - mkdir is /usr/bin/mkdir
7. echo $PATH - сперва bash проверяет, является ли команда встроенной, потом является ли команда псевдонимом, и потом в переменной $PATH
8. hash - команда для работы с кешем, можно смотреть, что запамятовано, можно удалять кеш, сперва программа ищет нужную команду и кеширует ее тут, а потом при такой же команде
достает ее из кеша
9. /bin/sh ~/development/studing/linux/test.sh - /bin/sh - это директива для системы, а не для оболочки
10. большинство команд, к-е мы вводим в терминале - єто внешне исполняемые файлы
11. есть 2 типа команд: внутренние команды ы внешние; внутренние команды, это команды, к-е зашиты в сам bash (например, cd, ls); 
внешние команды, к-е являются просто исполняемымы файлами (например, chmod, mkdir)
12. Для того, чтоб понять является команда внутренней или внешней, можно использовать команду type; type cd - cd is a shell builtin, type chmod - chmod is /usr/bin/chmod
13. PATH=$PATH:/var - тут мы добавляем переменную окружения, файл /var в перечень переменных окружения, к-е разедены двоеточием, например: 
- перед добавлением переменной /var:
 /home/artem/.nvm/versions/node/v22.13.1/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin
- после добавления переменной /var:
/home/artem/.nvm/versions/node/v22.13.1/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/var
в конце добавилась переменная-файл /var
14. $PATH - переменная в памяти, это не файл
15. grep -r - ключ -r означает, рукурсивный поиск
16. grep -r "root" /etc 2> /dev/null - 2> означает тут, что мы перенаправляем второй потом, поток ошибок в друго файл
17. grep -r "root:x" /etc 2> /dev/null - x в "root:x" означает некий "атавизм" пароля, 
пароль захешированный и с помощью этого символа через двоеточие мы правильнее достаем информаци; приблизительный ответ такой команды:
/etc/group-:root:x:0:
/etc/passwd:root:x:0:0:root:/root:/bin/bash
/etc/passwd-:root:x:0:0:root:/root:/bin/bash
/etc/group:root:x:0:
18. /dev/null - это файл под давление вывода; если мы что-то хотим подавить, перенаправляем сюда, этакая "черная дыра"
19. ps -efl - команда, к-я выводит процессы
20. Cron - плаинировщик задач, для запуска програм по расписанию; он не может работать чаще, чем 1 раз в минуту; это рабочая программа, к-я постоянно висит в памяти,
к-я активируется, запускается 1 раз в минуту
21. Cron бывает 2 типов: общий на всю систему и для конкретного пользователя.
22. ls -l /etc/crontab - тут находится конфигурационный файл для общего Cron
23. ls -l /var/spool/cron/crontabs/ - тут находится конфигурационный файл для индивидуального пользователя
24. в /etc/crontab файле мф може прописать настройки команды согласно последоательности временных параметров: минута-час-день-месяц-деньнедели-пользователь-команда;
например, */15 * * * * root come_command - означает, что запускаем какую-то команду каждые 15 минут, каждый час, каждый день, в каждом месяце, в любой день недели
от имени пользователя root; символ "/" указывает именно на каждые 15 минут, а не в 15 минут какого-то времени - если хотим казать в 15 минту какого-то час, то символ "/"
не указываем
25. в конфигурационном фале индивидуального планировщика задач полтзователь не указывается
26. * 2 * * * root some_command - каждый день в 2 часа ночи будет запущена эта команда каждую минуту, то есть 60 раз, поэтому всегда нужно уточнять параметры времени
27. 1 2 * * * root some_command (01 02 * * * root some_command) - команда будет запущена 1 раз в 2 часа ночи
28. высокосный год необходимо прописывать отдельно
29. символ * означает любое значение минуты или часа или другого параметра
30. crontab -e - команда для создания индивиуального конфигурационного файла-планировщика задач
31. при настройках планировщика задча необходимо учитывать время выполнения задачи; например планировщик задач 1 раз в минуту проверяет команды и срабатывает,
если находит совпадение по времени, и если какая-то программа из планировщика была запущена 1 минуту назад и все еще продолжает свое выполнение,
мы должны позаботится о том, чтоб эта команда не была вызвана снова; для этого можно использовать программу flock, нужно запускать проверки на последующие запуски
32. du -sh /home/artem/ - команда выводит информацию о том, сколько дискового пространства занимает пользователь artem
33. 

























